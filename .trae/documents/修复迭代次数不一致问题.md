## 问题分析

用户设置了10次迭代，但当前状态显示迭代了58次，这是因为：

1. **后端迭代计数基于iteration_history长度**：后端使用`iteration = len(global_optimizer.iteration_history)`计算当前迭代次数，而不是基于前端设置的`n_iter`
2. **iteration_history持续累积**：每次调用`_record_iteration`函数都会将迭代记录添加到`iteration_history`中，多次运行优化会导致迭代次数不断累积
3. **初始迭代计入iteration_history**：初始样本生成后会调用`_record_iteration(iteration=0, candidates=X_init)`，导致迭代次数从0开始

## 解决方案

### 1. 修改后端代码，使用独立的迭代计数器

在`TraceAwareKGOptimizer`类中添加独立的迭代计数器，确保每次初始化优化器时重置计数器：

```python
# 在__init__方法中添加
self.current_iteration = 0

# 修改_record_iteration方法，使用self.current_iteration而不是len(iteration_history)
self.current_iteration += 1
self._record_iteration(iteration=self.current_iteration, candidates=candidates)
```

### 2. 修改前端代码，确保只调用n_iter次

确保前端只调用`runSingleIteration`函数`n_iter`次，而不是基于后端返回的迭代次数：

```typescript
// 修改runOptimization函数
for (let i = 1; i <= algorithmParams.nIter; i++) {
    await runSingleIteration(i);
    await new Promise(resolve => setTimeout(resolve, 500));
}
```

### 3. 修改后端API，确保返回正确的迭代次数

修改后端API，确保返回的迭代次数与前端设置的`n_iter`一致：

```python
# 修改optimize_step函数，确保返回的iteration是当前运行的迭代次数，而不是iteration_history的长度
return {
    "success": True,
    "message": f"Iteration {current_run_iteration} completed",
    "iteration": current_run_iteration,
    # 其他返回字段
}
```

### 4. 确保每次初始化优化器时重置所有状态

确保每次初始化优化器时，重置所有相关状态，包括迭代计数器和iteration_history：

```python
# 在TraceAwareKGOptimizer的__init__方法中
self.iteration_history = []
self.current_iteration = 0
```

## 预期效果

1. 用户设置10次迭代，后端只运行10次迭代
2. 每次运行优化前，迭代计数器都会重置
3. 前端显示的迭代次数与后端实际运行的迭代次数一致
4. 多次点击"Start Search"按钮不会导致迭代次数累积

## 修改文件

1. `MyAiProj/SemiConductor_3obj/src/tkg_optimizer.py`：添加独立的迭代计数器
2. `bayesadhesion-optimize/App.tsx`：修改runOptimization函数，确保只调用n_iter次
3. `MyAiProj/api_server.py`：修改optimize_step函数，确保返回正确的迭代次数